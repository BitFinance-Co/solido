(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5850],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return f}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=s(n),f=o,b=p["".concat(c,".").concat(f)]||p[f]||d[f]||r;return n?a.createElement(b,i(i({ref:t},u),{},{components:n})):a.createElement(b,i({ref:t},u))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7886:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return l},toc:function(){return c},default:function(){return u}});var a=n(2122),o=n(9756),r=(n(7294),n(3905)),i={title:"balance",description:"Specification of the balance.rs module",keywords:["development","developers","lido","specification","intent","balance","solido","solana"],sidebar_position:4},l={unversionedId:"Guides/Development/Specification/Solido/balance",id:"Guides/Development/Specification/Solido/balance",isDocsHomePage:!1,title:"Balance",description:"Specification of the balance.rs module",source:"@site/docs/Guides/Development/Specification/Solido/balance.md",sourceDirName:"Guides/Development/Specification/Solido",slug:"/Guides/Development/Specification/Solido/balance",permalink:"/solido/docs/Guides/Development/Specification/Solido/balance",version:"current",sidebarPosition:4,frontMatter:{title:"balance",description:"Specification of the balance.rs module",keywords:["development","developers","lido","specification","intent","balance","solido","solana"],sidebar_position:4},sidebar:"solidoSidebar",previous:{title:"account_map",permalink:"/solido/docs/Guides/Development/Specification/Solido/account_map"},next:{title:"Entrypoint",permalink:"/solido/docs/Guides/Development/Specification/Solido/entrypoint"}},c=[{value:"Functions",id:"functions",children:[{value:"get_target_balance",id:"get_target_balance",children:[]},{value:"get_validator_furthest_below_target",id:"get_validator_furthest_below_target",children:[]}]}],s={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The purpose of this module is to hold functionality that assists with calculating target balances associated with validators."),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("p",null,"There are two functions within this module; one that is intended to get the ideal target balance for each validator and the second to get the validator that is the furthest below the ideal target balance along with its current balance."),(0,r.kt)("h3",{id:"get_target_balance"},"get_target_balance"),(0,r.kt)("p",null,"The intent of the get_target_balance function is to compare the current validator stake account balance to the ideal target balance of validators after any lamports that have not been delegated are taken into account.  The balances of the active validators is then updated to the target balance in a uniform fashion.  Any remainder due to rounding is also distributed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn get_target_balance(\n    undelegated_lamports: Lamports,\n    validators: &Validators,\n    target_balance: &mut [Lamports],\n) -> Result<(), LidoError> {\n")),(0,r.kt)("h3",{id:"get_validator_furthest_below_target"},"get_validator_furthest_below_target"),(0,r.kt)("p",null,"The intent of the get_validator_furthest_below_target function is to find the index and amount of the validator that is furthest from the ideal target balance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn get_validator_furthest_below_target(\n    validators: &Validators,\n    target_balance: &[Lamports],\n) -> (usize, Lamports) {\n")))}u.isMDXComponent=!0}}]);