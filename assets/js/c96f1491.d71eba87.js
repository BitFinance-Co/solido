(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5850],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return f}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),s=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=s(n),f=r,m=d["".concat(l,".").concat(f)]||d[f]||p[f]||a;return n?o.createElement(m,i(i({ref:t},u),{},{components:n})):o.createElement(m,i({ref:t},u))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7886:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return c},toc:function(){return l},default:function(){return u}});var o=n(2122),r=n(9756),a=(n(7294),n(3905)),i={title:"balance",description:"Specification of the balance.rs module",keywords:["development","developers","lido","specification","intent","balance","solido","solana"],sidebar_position:4},c={unversionedId:"Guides/Development/Specification/Solido/balance",id:"Guides/Development/Specification/Solido/balance",isDocsHomePage:!1,title:"Balance",description:"Specification of the balance.rs module",source:"@site/docs/Guides/Development/Specification/Solido/balance.md",sourceDirName:"Guides/Development/Specification/Solido",slug:"/Guides/Development/Specification/Solido/balance",permalink:"/solido/docs/Guides/Development/Specification/Solido/balance",version:"current",sidebarPosition:4,frontMatter:{title:"balance",description:"Specification of the balance.rs module",keywords:["development","developers","lido","specification","intent","balance","solido","solana"],sidebar_position:4},sidebar:"solidoSidebar",previous:{title:"account_map",permalink:"/solido/docs/Guides/Development/Specification/Solido/account_map"},next:{title:"Entrypoint",permalink:"/solido/docs/Guides/Development/Specification/Solido/entrypoint"}},l=[{value:"Functions",id:"functions",children:[{value:"get_target_balance",id:"get_target_balance",children:[]}]}],s={toc:l};function u(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,o.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The purpose of this module is to hold functionality that assists with calculating target balances associated with validators."),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("p",null,"There are two functions within this module; one that is intended to get the ideal target balance for each validator and the second to get the validator that is the furthest below the ideal target balance along with its current balance."),(0,a.kt)("h3",{id:"get_target_balance"},"get_target_balance"),(0,a.kt)("p",null,"The intent of the get_target_balance function is to compare the current validator balance to the ideal target balance of validators after any lamports that have not been delegated are taken into account."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn get_target_balance(\n    undelegated_lamports: Lamports,\n    validators: &Validators,\n    target_balance: &mut [Lamports],\n) -> Result<(), LidoError> {\n")))}u.isMDXComponent=!0}}]);